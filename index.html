<!DOCTYPE HTML>
<html>
  <head>
    <title>ZigFu Skeleton Tracking</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/styles.css">
  </head>
  <body>
  	<script src="js/jquery.1.7.1.min.js"></script>
  	<script type="text/javascript" src="js/three.min.js"></script>
  	<script type="text/javascript" src="js/requestAnimationFrame.js"></script>
  	<script src="js/zig.min.js"></script>
  
    <div id="pluginContainer">
      <object id="zigPlugin" type="application/x-zig" width="0" height="0">
        <param name="onload" value="zigPluginLoaded">
      </object>
    </div>

    <script>

      var k_camera, k_scene, k_renderer;
      var skeletonPoints = [];
      var skeletonLines = [];
      var noKick;
      var goalMade = false;
      var backgroundTime;
      var width = 640;
      var height = 480;
      var ball;
      var soccerBall;
      var leftGoalPost;

      k_init();
      k_animate();

      drawSoccerBall();
      drawGoal();
      //drawPlanes();

      //Initiate the three.js scene
      //This is the black kinectSkeletonBox div

      function k_init() {
        var k_container = document.createElement('div');

        k_container.setAttribute("id", "kinectSkeletonBox");

        //var width = 640;
        //var height = 480;

        document.body.appendChild(k_container);
        k_camera = new THREE.PerspectiveCamera(60, width / height, 1, 10000);

        k_camera.position.z = 250;
        k_scene = new THREE.Scene();
        k_renderer = new THREE.WebGLRenderer();
        k_renderer.setSize(width, height);
        k_container.appendChild(k_renderer.domElement);

        // skeleteon points initializations
        for(var i = 0; i < 25; i++) {
          //Make 25 white circles for each of the joints we are going to recieve from the kinect feed.
          var material = new THREE.MeshBasicMaterial({ color : 0xffffff });
          var particleGeom = new THREE.SphereGeometry( 5, 16, 8 );
          var particle = new THREE.Mesh( particleGeom.clone(), material );
          
          //Place the circles way off screen until we get user data from the kinect.
          particle.position.x = Math.floor((Math.random()*100)+1);   
          particle.position.y = Math.floor((Math.random()*100)+1);
          particle.position.z = Math.floor((Math.random()*100)+1);
          particle.position.multiplyScalar(Math.random() * 3 + 50);
          if(i==1){ //make the head 3x bigger than rest of joints
            particle.scale.x = particle.scale.y = 3;
          }else{
            particle.scale.x = particle.scale.y = 1;
          }
          particle.material = material;
          
          k_scene.add(particle);
          skeletonPoints.push(particle);  
        }

        // draw lines in between each joint
        skeletonLines = [
          new drawSkeletonLine(zig.Joint.Head, zig.Joint.Neck),
          new drawSkeletonLine(zig.Joint.Neck, zig.Joint.LeftShoulder),
          new drawSkeletonLine(zig.Joint.Neck, zig.Joint.RightShoulder),
          new drawSkeletonLine(zig.Joint.LeftShoulder, zig.Joint.LeftHip),
          new drawSkeletonLine(zig.Joint.RightShoulder, zig.Joint.RightHip),
          new drawSkeletonLine(zig.Joint.LeftShoulder, zig.Joint.LeftElbow),
          new drawSkeletonLine(zig.Joint.LeftElbow, zig.Joint.LeftHand),
          new drawSkeletonLine(zig.Joint.RightShoulder, zig.Joint.RightElbow),
          new drawSkeletonLine(zig.Joint.RightElbow, zig.Joint.RightHand),
          new drawSkeletonLine(zig.Joint.LeftHip, zig.Joint.RightHip),
          new drawSkeletonLine(zig.Joint.LeftHip, zig.Joint.LeftKnee),
          new drawSkeletonLine(zig.Joint.LeftKnee, zig.Joint.LeftFoot),
          new drawSkeletonLine(zig.Joint.RightHip, zig.Joint.RightKnee),
          new drawSkeletonLine(zig.Joint.RightKnee, zig.Joint.RightFoot)
        ];

        ball = new ball();
      }

      function drawSkeletonLine(joint1, joint2) {
        var geometry = new THREE.Geometry();
        geometry.vertices.push(skeletonPoints[joint1].position);
        geometry.vertices.push(skeletonPoints[joint2].position);
        var line = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0xffffff, linewidth: 10}));
        k_scene.add(line);

        function update() {
          line.geometry.vertices[0].set(skeletonPoints[joint1].position.x,skeletonPoints[joint1].position.y,skeletonPoints[joint1].position.z);
          line.geometry.vertices[1].set(skeletonPoints[joint2].position.x,skeletonPoints[joint2].position.y,skeletonPoints[joint2].position.z);
          line.geometry.verticesNeedUpdate = true;
        }
        update();
        return {update:update};
      }

      function drawSoccerBall() {
        // Spheres
        // Note: a standard flat rectangular image will look distorted. A "spherical projection" image will look "normal".

        var light2 = new THREE.AmbientLight(0x444444);
        k_scene.add(light2);
        
        // soccer ball
        var soccerBallTexture = THREE.ImageUtils.loadTexture( 'img/soccerBall.jpg' );
        var soccerBallMaterial = new THREE.MeshBasicMaterial( { map: soccerBallTexture, side: THREE.DoubleSide } );
        var sphereGeom =  new THREE.SphereGeometry( 15, 16, 8 );// radius, segmentsWidth, segmentsHeight
        soccerBall = new THREE.Mesh( sphereGeom.clone(), soccerBallMaterial );
        soccerBall.position.set(0, -100, 0);
        k_scene.add( soccerBall );
      }

      function drawGoal() {
        //goal post material and geometry
        var goalPostTexture = THREE.ImageUtils.loadTexture( 'img/goalPost.jpg' );
        var goalPostMaterial = new THREE.MeshBasicMaterial( { map: goalPostTexture, side: THREE.DoubleSide } );
        var sidePostGeom = new THREE.CubeGeometry( 10, 130, 1, 1, 1, 1 );
        var topPostGeom = new THREE.CubeGeometry( 290, 10, 1, 1, 1, 1 );

        //left post
        leftGoalPost = new THREE.Mesh( sidePostGeom.clone(), goalPostMaterial );
        leftGoalPost.position.set(-150,0,-250);
        k_scene.add( leftGoalPost );

        //top post
        topGoalPost = new THREE.Mesh( topPostGeom.clone(), goalPostMaterial );
        topGoalPost.position.set(0,60,-250);
        k_scene.add( topGoalPost );

        //left post
        rightGoalPost = new THREE.Mesh( sidePostGeom.clone(), goalPostMaterial );
        rightGoalPost.position.set(150,0,-250);
        k_scene.add( rightGoalPost );
      }

      function drawPlanes() {
        // X axis
        geometry = new THREE.PlaneGeometry(600, 200);
        material = new THREE.MeshBasicMaterial({
          color: 0x7f7f7f,
          transparent: false,
          opacity: 0.5
        });
        plane = new THREE.Mesh(geometry, material);
        plane.rotation.x = 5;
        plane.position.z = -350;
        k_scene.add(plane);

        // Y axis
        geometry = new THREE.PlaneGeometry(600, 200);
        material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.75
        });
        plane = new THREE.Mesh(geometry, material);
        plane.rotation.y = 1.5;
        plane.position.z = -380;
        k_scene.add(plane);
      }

      var current_user;
      function zigPluginLoaded() {
        zig.init(document.getElementById("zigPlugin"));
        console.log("zig plugin loaded");
        zig.addEventListener('userfound', function(user) {
          console.log('Found user. ID: ' + user.id);
          current_user = user;
          current_user.addEventListener('userupdate', function(user) {
            //This is called every time the kinect has new user skeleton data
            moveDots(user);
          });
          zig.addListener(current_user);
        });
      }

      function moveDots(user){

        for(var i = 0; i < skeletonPoints.length; i++) {
        //Loop through each of the dots
        
          var kinectFeedPart = user.skeleton[i];
          //Get data information for each joint.
          if( typeof kinectFeedPart == 'undefined' || kinectFeedPart.id == 3 /*hiding torso*/ ) { //If joint data isnt avaiable place dot offscreen and continue on.
            var object = skeletonPoints[i];
            object.position.x = 5000;
            object.position.y = 5000;

            continue;
          }
          var kinectFeedPosition = kinectFeedPart.position;
          var object = skeletonPoints[i];
          object.position.x = kinectFeedPosition[0] / 5;
          object.position.y = (kinectFeedPosition[1] / 5) - 100;
          object.position.z = -kinectFeedPosition[2] / 5;
        }
      }

      function footMovement() {
        var rFoot = skeletonPoints[zig.Joint.RightFoot].position;
        var lFoot = skeletonPoints[zig.Joint.LeftFoot].position;
        var rHip = skeletonPoints[zig.Joint.RightHip].position;
        var lHip = skeletonPoints[zig.Joint.LeftHip].position;

        if( rFoot == null || lFoot == null || rHip == null || lHip == null ) {
          return;
        } else {
          if( rFoot.z > (rHip.z + 100) || lFoot.z > (lHip.z + 100) ) {
            if( (rFoot.z > lFoot.z) && (noKick != true) ) {
              ball.kick(rFoot.x, rFoot.y, (rHip.x)-(rFoot.x));
              noKick = true;
              console.log("right kick");
            } else if ( (rFoot.z < lFoot.z) && (noKick != true) ){
              ball.kick(lFoot.x, lFoot.y, (lHip.x)-(lFoot.x));
              noKick = true;
              console.log("left kick");
            } 
          } else {
            noKick = false;
          }
        }
      }

      function ball() {
    
        var STARTYSPEED = 10;
        var STARTZSPEED = 20;
        
        var x = 0;
        var y = 0; 
        var z = 0;
        var xSpeed;
        var ySpeed = STARTYSPEED;
        var zSpeed = STARTZSPEED;
        var rotationSpeed;
        var rotation = 0;
        var gravity = 0.3;
        var active = false;
        var ground = 0;
        
        function kick( xFoot, yFoot, xHipFoot) {
          if(active == false) {
            active = true;
            x = xFoot;
            y = -100/*yFoot*/;
            xSpeed = xHipFoot;
          }
        }
        
        function update() {
          if(active == true) {
            if(z > -1500) {
              z -= zSpeed;
              ySpeed -= gravity;
              y += ySpeed;
              x -= xSpeed/2;
              soccerBall.position.set(x,y,z);
              console.log("x: " + x);
              console.log("y: " + y);
              console.log("z: " + z);
              if(y == ground) console.log("ball hit the ground");
            } else {
              //if( x < ((width/2) + (goal.width/2*goalScale)) && y < ((height/2) + (goal.height/2*goalScale)) && x > ((width/2) - (goal.width/2*goalScale)) && y > ((height/2) - (goal.height/2*goalScale)) ) {
                console.log("z: " + z);
                goalMade = true;
                console.log("GOOOOOOOAL");
              //} else {
                //console.log("MISS");
              //}
              backgroundTime = new Date().getTime();

              //soccerBall couldn't be accessed in reset() method, so I added it to the update method
              //reset();

              // reseting the ball and its variables
              active = false;
              x = 0;
              y = -100;
              z = 0;
              xSpeed = 0;
              ySpeed = STARTYSPEED;
              zSpeed = STARTZSPEED;
              rotationSpeed = 0;
              rotation = 0 ;
              soccerBall.position.set(x,y,z);
            }
          }
        }
        
        // function reset() {
        //   active = false;
        //   x = 0;
        //   y = 0;
        //   z = 0;
        //   xSpeed = 0;
        //   ySpeed = STARTYSPEED;
        //   zSpeed = STARTZSPEED;
        //   rotationSpeed = 0;
        //   rotation = 0 ;
        //   soccerBall.position.set(x, y, z);
        // }

        return {update:update, kick:kick/*, reset:reset*/};
      }

      //Animating and rendering for three.js scene

      function k_animate() {
        requestAnimationFrame(k_animate);
        k_render();
      }

      function k_render() {
        //k_camera.position.x += (0 - k_camera.position.x ) * .05;
        //k_camera.position.y += (200 - k_camera.position.y ) * .05;
        k_camera.lookAt(k_scene.position);
        k_renderer.render(k_scene, k_camera);
        for(var n = 0; n < skeletonLines.length; n++) {
          skeletonLines[n].update();
        }
        footMovement();
        ball.update();
      }

    </script>
  </body>
</html>