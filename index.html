<!DOCTYPE HTML>
<html>
  <head>
    <title>ZigFu Skeleton Tracking</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/styles.css">
  </head>
  <body>
  	<script src="js/jquery.1.7.1.min.js"></script>
  	<script type="text/javascript" src="js/three.min.js"></script>
  	<script type="text/javascript" src="js/requestAnimationFrame.js"></script>
  	<script src="js/zig.min.js"></script>
  
    <div id="pluginContainer">
      <object id="zigPlugin" type="application/x-zig" width="0" height="0">
        <param name="onload" value="zigPluginLoaded">
      </object>
    </div>

    <script>

      var k_camera, k_scene, k_renderer;
      var skeletonPoints = [];
      var skeletonLines = [];

      k_init();
      k_animate();

      //drawSoccerBall();

      //Initiate the three.js scene that we are going to draw dots onto.
      //This is the black kinectSkeletonBox div

      function k_init() {
        var k_container = document.createElement('div');

        k_container.setAttribute("id", "kinectSkeletonBox");

        var width = 500;
        var height = 500;

        document.body.appendChild(k_container);
        k_camera = new THREE.PerspectiveCamera(100, width / height, 1, 10000);

        k_camera.position.z = 250;
        k_scene = new THREE.Scene();
        k_renderer = new THREE.WebGLRenderer();
        k_renderer.setSize(width, height);
        k_container.appendChild(k_renderer.domElement);

        // skeleteon points initializations
        for(var i = 0; i < 25; i++) {
          //Make 25 white circles for each of the joints we are going to recieve from the kinect feed.
          var material = new THREE.MeshBasicMaterial({ color : 0xffffff });
          var particleGeom = new THREE.SphereGeometry( 5, 16, 8 );
          var particle = new THREE.Mesh( particleGeom.clone(), material );
          
          //Place the circles way off screen until we get user data from the kinect.
          particle.position.x = Math.floor((Math.random()*100)+1);   
          particle.position.y = Math.floor((Math.random()*100)+1);
          particle.position.z = Math.floor((Math.random()*100)+1);
          particle.position.multiplyScalar(Math.random() * 3 + 50);
          if(i==1){ //make the head 2.5x bigger than rest of joints
            particle.scale.x = particle.scale.y = 5;
          }else{
            particle.scale.x = particle.scale.y = 2;
          }
          particle.material = material;
          
          k_scene.add(particle);
          skeletonPoints.push(particle);  
        }

        // draw lines in between each joint
        skeletonLines = [
          new drawSkeletonLine(zig.Joint.Head, zig.Joint.Neck),
          new drawSkeletonLine(zig.Joint.Neck, zig.Joint.LeftShoulder),
          new drawSkeletonLine(zig.Joint.Neck, zig.Joint.RightShoulder),
          new drawSkeletonLine(zig.Joint.LeftShoulder, zig.Joint.LeftHip),
          new drawSkeletonLine(zig.Joint.RightShoulder, zig.Joint.RightHip),
          new drawSkeletonLine(zig.Joint.LeftShoulder, zig.Joint.LeftElbow),
          new drawSkeletonLine(zig.Joint.LeftElbow, zig.Joint.LeftHand),
          new drawSkeletonLine(zig.Joint.RightShoulder, zig.Joint.RightElbow),
          new drawSkeletonLine(zig.Joint.RightElbow, zig.Joint.RightHand),
          new drawSkeletonLine(zig.Joint.LeftHip, zig.Joint.RightHip),
          new drawSkeletonLine(zig.Joint.LeftHip, zig.Joint.LeftKnee),
          new drawSkeletonLine(zig.Joint.LeftKnee, zig.Joint.LeftFoot),
          new drawSkeletonLine(zig.Joint.RightHip, zig.Joint.RightKnee),
          new drawSkeletonLine(zig.Joint.RightKnee, zig.Joint.RightFoot)
        ];
      }

      function drawSkeletonLine(joint1, joint2) {
        var geometry = new THREE.Geometry();
        geometry.vertices.push(skeletonPoints[joint1].position);
        geometry.vertices.push(skeletonPoints[joint2].position);
        var line = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0xffffff, linewidth: 10}));
        k_scene.add(line);

        function update() {
          line.geometry.vertices[0].set(skeletonPoints[joint1].position.x,skeletonPoints[joint1].position.y,skeletonPoints[joint1].position.z);
          line.geometry.vertices[1].set(skeletonPoints[joint2].position.x,skeletonPoints[joint2].position.y,skeletonPoints[joint2].position.z);
          line.geometry.verticesNeedUpdate = true;
        }
        update();
        return {update:update};
      }

      function drawSoccerBall() {
        // Spheres
        // Note: a standard flat rectangular image will look distorted. A "spherical projection" image will look "normal".

        var light2 = new THREE.AmbientLight(0x444444);
        k_scene.add(light2);
        
        // soccer ball
        var soccerBallTexture = THREE.ImageUtils.loadTexture( 'img/soccerBall2.jpg' );
        var soccerBallMaterial = new THREE.MeshBasicMaterial( { map: soccerBallTexture, side: THREE.DoubleSide } );
        var sphereGeom =  new THREE.SphereGeometry( 20, 16, 8 );// radius, segmentsWidth, segmentsHeight
        var soccerBall = new THREE.Mesh( sphereGeom.clone(), soccerBallMaterial );
        soccerBall.position.set(0, 0, 0);
        k_scene.add( soccerBall );  
      }

      var current_user;
      function zigPluginLoaded() {
        zig.init(document.getElementById("zigPlugin"));
        console.log("zig plugin loaded");
        zig.addEventListener('userfound', function(user) {
          console.log('Found user. ID: ' + user.id);
          current_user = user;
          current_user.addEventListener('userupdate', function(user) {
            //This is called every time the kinect has new user skeleton data
            moveDots(user);
          });
          zig.addListener(current_user);
        });
      }

      function moveDots(user){

        for(var i = 0; i < skeletonPoints.length; i++) {
        //Loop through each of the dots
        
          var kinectFeedPart = user.skeleton[i];
          //Get data information for each joint.
          if( typeof kinectFeedPart == 'undefined' || kinectFeedPart.id == 3 /*hiding torso*/ ) { //If joint data isnt avaiable place dot offscreen and continue on.
            var object = skeletonPoints[i];
            object.position.x = 5000;
            object.position.y = 5000;

            continue;
          }
          var kinectFeedPosition = kinectFeedPart.position;
          var object = skeletonPoints[i];
          object.position.x = kinectFeedPosition[0] / 5;
          object.position.y = kinectFeedPosition[1] / 5;
          object.position.z = -kinectFeedPosition[2] / 5;
        }
      }

      ///Animating and rendering for three.js scene

      function k_animate() {
        requestAnimationFrame(k_animate);
        k_render();
      }

      function k_render() {
        k_camera.position.x += (0 - k_camera.position.x ) * .05;
        k_camera.position.y += (200 - k_camera.position.y ) * .05;
        k_camera.lookAt(k_scene.position);
        k_renderer.render(k_scene, k_camera);
        for(var n = 0; n < skeletonLines.length; n++) {
          skeletonLines[n].update();
        }
      }

    </script>
  </body>
</html>